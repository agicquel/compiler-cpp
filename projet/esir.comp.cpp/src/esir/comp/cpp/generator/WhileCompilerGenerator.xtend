/*
 * generated by Xtext 2.19.0
 */
package esir.comp.cpp.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import esir.comp.cpp.generator.ir.WhileDslIRGenerator
import esir.comp.cpp.generator.ir.FunctionImpl
import java.util.List
import org.eclipse.xtend.lib.annotations.Accessors

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhileCompilerGenerator extends AbstractGenerator {
		@Accessors String outputFile;
		WhileDslIRGenerator irGenerator
		List<FunctionImpl> ir
		
		new (String outputFile) {
			this.outputFile = outputFile
		}
		
		new () {
			this.outputFile = "out.cpp"
		}
		
		override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		this.irGenerator = new WhileDslIRGenerator()
		this.ir = irGenerator.compileIR(resource)
		
		var generatedCode = ""
		var functionDecl = "#include \"libWh.h\"\n\n"
		for(irFunction : ir) {
			//println(irFunction)
			functionDecl += "void " + irFunction.functionName + "(std::stack<bin_tree::bin_tree_ptr> * f_stack); // " + irFunction.function.functionName + "\n"
			generatedCode += irFunction.compile() + "\n\n"
		}
		
		functionDecl += "\nint main(int argc, char *argv[]) {\n"
			+ "\treturn libWh::run(argc, argv);\n}\n\n"
		
		fsa.generateFile(
			this.outputFile,
			functionDecl + generatedCode)
	}
	
	def String compile(FunctionImpl ir) {
		var cpp = "// Function : " + ir.function.functionName + "\n"

		// generate function declaration
		if(ir.env.outputCounter > 1) {
			cpp += ""
		}
		cpp += "void " + ir.functionName + '(std::stack<bin_tree::bin_tree_ptr> * f_stack)\n{\n'
		
		for(var i = 0; i < ir.env.inputCounter; i++) {
			cpp += "bin_tree::bin_tree_ptr I" + i + " = bin_tree::nil();\n"; // 
		}
		for(var i = 0; i < ir.env.variableCounter; i++) {
			cpp += "bin_tree::bin_tree_ptr	 V" + i + " = bin_tree::nil();\n"; // 
		}
		
		cpp += "\n"
		
		// generate core function code
		for(quad : ir.quads) {
			var op_arr = quad.op.split("\\s+")
			switch op_arr.get(0) {
				case "nil" : {
					cpp += quad.dest + " = bin_tree::nil();\n"
				}
				case "symb" : {
					cpp += quad.dest + " = std::make_shared<bin_tree>(\"" + op_arr.get(1) + "\");\n"
				}
				case "cons" : {
					cpp += quad.dest + " = " + "bin_tree::cons(" + quad.arg1 + ", " + quad.arg2 + ");\n"
				}
				case "hd" : {
					cpp += quad.dest + " = " + "bin_tree::hd(" + quad.arg1 + ");\n"
				}
				case "tl" : {
					cpp += quad.dest + " = " + "bin_tree::tl(" + quad.arg1 + ");\n"
				}
				case "ifeq" : {
					cpp += "if(bin_tree::equals(" + quad.arg1 + "," + quad.arg2 + ")) { goto " + op_arr.get(1) + "; }\n"
				}
				case "ift" : {
					cpp += "if(" + quad.arg1 + "->isTrue()) { goto " + op_arr.get(1) + "; }\n"
				}
				case "iff" : {
					cpp += "if(" + quad.arg1 + "->isFalse()) { goto " + op_arr.get(1) + "; }\n"
				}
				case "goto" : {
					cpp += "goto "+ op_arr.get(1) + ";\n"
				}
				case "label" : {
					cpp += op_arr.get(1) + " :\n"
				}
				case "write" : {
					cpp += "f_stack->push(" + quad.arg1 + ");\n" // ->clone()
				}
				case "read" : {
					cpp +=  quad.dest + " = f_stack->top();\nf_stack->pop();\n"
				}
				case "nop" : {
					cpp += "bin_tree::nop();\n"
				}
				case "true" : {
					cpp += quad.dest + " = bin_tree::getTrue();\n"
				}
				case "false" : {
					cpp += quad.dest + " = bin_tree::getFalse();\n"
				}
				case "call" : {
					var funName = ""
					for(f : this.ir) {
						if(f.function.functionName.equals(op_arr.get(1))) {
							funName = f.functionName
							//break
						}
					}
					if(funName.isNullOrEmpty()) {
						throw new Exception("Function " + op_arr.get(1) + " does not exist.")
					}
					cpp += funName + "(f_stack);\n"
				}
			}
		}
		
		cpp += "}\n"
		return cpp
	}
	
}
