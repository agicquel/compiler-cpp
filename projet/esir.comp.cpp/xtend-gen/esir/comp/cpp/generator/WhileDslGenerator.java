/**
 * generated by Xtext 2.19.0
 */
package esir.comp.cpp.generator;

import esir.comp.cpp.generator.ir.FunctionImpl;
import esir.comp.cpp.generator.ir.Quad;
import esir.comp.cpp.generator.ir.WhileDslIRGenerator;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class WhileDslGenerator extends AbstractGenerator {
  private WhileDslIRGenerator irGenerator;
  
  private List<FunctionImpl> ir;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    WhileDslIRGenerator _whileDslIRGenerator = new WhileDslIRGenerator();
    this.irGenerator = _whileDslIRGenerator;
    this.ir = this.irGenerator.compileIR(resource);
    String generatedCode = "";
    for (final FunctionImpl irFunction : this.ir) {
      {
        InputOutput.<FunctionImpl>println(irFunction);
        String _generatedCode = generatedCode;
        String _compile = this.compile(irFunction);
        String _plus = (_compile + "\n\n");
        generatedCode = (_generatedCode + _plus);
      }
    }
    fsa.generateFile(
      "code.cpp", generatedCode);
  }
  
  public String compile(final FunctionImpl ir) {
    try {
      String _functionName = ir.getFunction().getFunctionName();
      String _plus = ("// Function : " + _functionName);
      String cpp = (_plus + "\n");
      int _outputCounter = ir.getEnv().getOutputCounter();
      boolean _greaterThan = (_outputCounter > 1);
      if (_greaterThan) {
        String _cpp = cpp;
        cpp = (_cpp + "");
      }
      String _cpp_1 = cpp;
      String _functionName_1 = ir.getFunctionName();
      String _plus_1 = ("void " + _functionName_1);
      String _plus_2 = (_plus_1 + "(std::stack<bin_tree> * f_stack)\n{\n");
      cpp = (_cpp_1 + _plus_2);
      for (int i = 0; (i < ir.getEnv().getInputCounter()); i++) {
        String _cpp_2 = cpp;
        cpp = (_cpp_2 + (("bin_tree I" + Integer.valueOf(i)) + ";\n"));
      }
      for (int i = 0; (i < ir.getEnv().getVariableCounter()); i++) {
        String _cpp_2 = cpp;
        cpp = (_cpp_2 + (("bin_tree V" + Integer.valueOf(i)) + ";\n"));
      }
      String _cpp_2 = cpp;
      cpp = (_cpp_2 + "\n");
      ArrayList<Quad> _quads = ir.getQuads();
      for (final Quad quad : _quads) {
        {
          String[] op_arr = quad.getOp().split("\\s+");
          String _get = op_arr[0];
          if (_get != null) {
            switch (_get) {
              case "nil":
                String _cpp_3 = cpp;
                String _dest = quad.getDest();
                String _plus_3 = (_dest + " = bin_tree::nil();\n");
                cpp = (_cpp_3 + _plus_3);
                break;
              case "cons":
                String _cpp_4 = cpp;
                String _dest_1 = quad.getDest();
                String _plus_4 = (_dest_1 + " = ");
                String _plus_5 = (_plus_4 + "bin_tree::cons(");
                String _arg1 = quad.getArg1();
                String _plus_6 = (_plus_5 + _arg1);
                String _plus_7 = (_plus_6 + ", ");
                String _arg2 = quad.getArg2();
                String _plus_8 = (_plus_7 + _arg2);
                String _plus_9 = (_plus_8 + ");\n");
                cpp = (_cpp_4 + _plus_9);
                break;
              case "hd":
                String _cpp_5 = cpp;
                String _dest_2 = quad.getDest();
                String _plus_10 = (_dest_2 + " = ");
                String _plus_11 = (_plus_10 + "bin_tree::hd(");
                String _arg1_1 = quad.getArg1();
                String _plus_12 = (_plus_11 + _arg1_1);
                String _plus_13 = (_plus_12 + ");\n");
                cpp = (_cpp_5 + _plus_13);
                break;
              case "tl":
                String _cpp_6 = cpp;
                String _dest_3 = quad.getDest();
                String _plus_14 = (_dest_3 + " = ");
                String _plus_15 = (_plus_14 + "bin_tree::tl(");
                String _arg1_2 = quad.getArg1();
                String _plus_16 = (_plus_15 + _arg1_2);
                String _plus_17 = (_plus_16 + ");\n");
                cpp = (_cpp_6 + _plus_17);
                break;
              case "ifeq":
                String _cpp_7 = cpp;
                String _arg1_3 = quad.getArg1();
                String _plus_18 = ("if(bin_tree::equals(&" + _arg1_3);
                String _plus_19 = (_plus_18 + ", &");
                String _arg2_1 = quad.getArg2();
                String _plus_20 = (_plus_19 + _arg2_1);
                String _plus_21 = (_plus_20 + ")) { goto ");
                String _get_1 = op_arr[1];
                String _plus_22 = (_plus_21 + _get_1);
                String _plus_23 = (_plus_22 + "; }\n");
                cpp = (_cpp_7 + _plus_23);
                break;
              case "ift":
                String _cpp_8 = cpp;
                String _arg1_4 = quad.getArg1();
                String _plus_24 = ("if(" + _arg1_4);
                String _plus_25 = (_plus_24 + ".isTrue()) { goto ");
                String _get_2 = op_arr[1];
                String _plus_26 = (_plus_25 + _get_2);
                String _plus_27 = (_plus_26 + "; }\n");
                cpp = (_cpp_8 + _plus_27);
                break;
              case "iff":
                String _cpp_9 = cpp;
                String _arg1_5 = quad.getArg1();
                String _plus_28 = ("if(" + _arg1_5);
                String _plus_29 = (_plus_28 + ".isFalse()) { goto ");
                String _get_3 = op_arr[1];
                String _plus_30 = (_plus_29 + _get_3);
                String _plus_31 = (_plus_30 + "; }\n");
                cpp = (_cpp_9 + _plus_31);
                break;
              case "goto":
                String _cpp_10 = cpp;
                String _get_4 = op_arr[1];
                String _plus_32 = ("goto " + _get_4);
                String _plus_33 = (_plus_32 + ";\n");
                cpp = (_cpp_10 + _plus_33);
                break;
              case "label":
                String _cpp_11 = cpp;
                String _get_5 = op_arr[1];
                String _plus_34 = (_get_5 + " :\n");
                cpp = (_cpp_11 + _plus_34);
                break;
              case "write":
                String _cpp_12 = cpp;
                String _arg1_6 = quad.getArg1();
                String _plus_35 = ("f_stack->push(" + _arg1_6);
                String _plus_36 = (_plus_35 + ");\n");
                cpp = (_cpp_12 + _plus_36);
                break;
              case "read":
                String _cpp_13 = cpp;
                String _dest_4 = quad.getDest();
                String _plus_37 = (_dest_4 + " = f_stack->top();\nf_stack->pop();\n");
                cpp = (_cpp_13 + _plus_37);
                break;
              case "nop":
                String _cpp_14 = cpp;
                cpp = (_cpp_14 + "bin_tree::nop();\n");
                break;
              case "true":
                String _cpp_15 = cpp;
                String _dest_5 = quad.getDest();
                String _plus_38 = (_dest_5 + " = bin_tree::getTrue();\n");
                cpp = (_cpp_15 + _plus_38);
                break;
              case "false":
                String _cpp_16 = cpp;
                String _dest_6 = quad.getDest();
                String _plus_39 = (_dest_6 + " = bin_tree::getFalse();\n");
                cpp = (_cpp_16 + _plus_39);
                break;
              case "call":
                String funName = "";
                for (final FunctionImpl f : this.ir) {
                  boolean _equals = f.getFunction().getFunctionName().equals(op_arr[1]);
                  if (_equals) {
                    funName = f.getFunctionName();
                  }
                }
                boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(funName);
                if (_isNullOrEmpty) {
                  String _get_6 = op_arr[1];
                  String _plus_40 = ("Function " + _get_6);
                  String _plus_41 = (_plus_40 + " does not exist.");
                  throw new Exception(_plus_41);
                }
                String _cpp_17 = cpp;
                cpp = (_cpp_17 + (funName + "(f_stack);\n"));
                break;
            }
          }
        }
      }
      String _cpp_3 = cpp;
      cpp = (_cpp_3 + "}\n");
      return cpp;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
